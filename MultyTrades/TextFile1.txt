
------------------------------------------------------------ PROGRAM.CS ------------------------------------------------------------

Вся программа состоит из процессов(VS,Word,Any Desk...) кот состоят из threads.Процесс заканчивается только когда заканчиваются 
все Threads его.
Foreground - важный трэйд
Daemon - второстепеный трэйдПроцессор может задействовать только один трэйд одновременно.
Библиотека TPN разбивает большой трэйд на несколько трейдов более маленьких. К примеру, Main - это трэйд, кот в свою очередь можно
разбить на несколько небольших трэйдов.

Если в режиме Debug навести курсор на ct то в intellicenc получим следующую инфу:
     IsAlive (true/false) => продолжает работать или закончился;
     IsBackground (true/false) => трэйд главный или второстепеный;
     IsThreadPoolThread (true/false) => это патерн в проге кот позволяет концентрировать много трэйдов в одном месте,
        чтобы их можно было быстро задействовать;
     ManagedThreadId => это трэйд кот привязан к CLR. На курсе мы будем работать толька с такими трэйдами;
     Name => имя не всегда вводят -- эта вещь не обязательна;
     Priority => Степень значимости данного трэйда (HiPriority,Normal,LowPriority). Уже не используют т.к было много проблем
     ThreadState => на каком этапе находится данный трэйд (Running, Start ...)

 int result = Convert.ToInt32(Console.ReadLine()) --> Этот процесс называется "BLOCKING". В это время комп висит и ждёт пока
     пользователь не введёт требуюмую инфу. Чтобы избежать такую потерю времени были придуманы трэйды ("THREAD")
 Трэйды предназначены, для того чтобы в это время комп что-то делал, а не ждал пока дейтсвующий процесс закончится.
Thread t1_ = new Thread(() => { }) --> так создают Thread по имени "t1" с "lambda expression" --> это безымяная фукция где "() =>
     означает что это функция у которой есть тело. Тело функции пишут в "{}"
                
Thread t1 = new Thread(foo) -- создаёт Thread по имени t1 ,кот обращается к функции кот не является безымяной.
     (в даном примере обращении идёт к ф-ции по имени "foo"):

Thread.Sleep(1000) --> он прекращает работу Thread на то к-во времени кот указано в скобках. Выполнил итерацию 
      и "заснул" --> указаное время прошло --> "проснулся" и выполнил следующую итерацию цикла в Main.

После выполнения приведённого ниже -- t1.Start() -- трэд по имени t1 начнёт выполняться. А трэд Main "заснёт". 

Трэд t1 выполнит свои десять итераций в ф-ции "foo" раньше, чем трэд Main проснётся т.к каждая итерация его цикла "засыпает"
на 80 милисекунд, то есть весь цикл выполнится за 80*10=800 милисекунд а "сон" Main длится 1000 милисекунд(Sleep(1000))
800<1000 --> поэтому цикл ф-ции foo выполнится быстрее чем "проснётся" трэд в MAIN.
В том случае, когда трэйд  t1 не успервает полностью выполнить весь цикл до того когда трэд MAIN проснётся (t1.Sleep(200) -->
200*10 = 2000 --> 2000 > 1000), то эти два трэда начинают работать одновремено 

t1.IsBackground = true --> это распоряжение превращает трэд t1 во второстепеный трэд. Все второстепеные трэды заканчиваются вместе с
    основным трэдом (в нашем случае основной трэд это MAIN) и не важно успели они закончится или нет. По умолчанию все трэды являются
    основными ("foreground"), т.е "IsBackground = false". Чтобы "превратить" их во второстепеные используется команда "IsBackground
    = true"

Если нужно сохранить все трэды как основные, но при этом они все должны закончится с завершением работы MAIN, то для этого нужно
использовать команду ABORT. Для этого нужно поместить все трэды кроме MAIN в отдельный LIST:
    
 
Thread.CurrentThread.ManagedThreadId} --> эта команда возвращает порядковый номер трэда (его уникальное имя или номер), кот
    автоматически присваивает ему комп.
    static void Main(string[] args)
    { 
            List<Thread> threads = new List<Thread>();
            for (int i = 3; i >= 0; i--)
            {
                ...............
                ...............
                ...............
                Thread t1 = new Thread(foo);
                threads.Add(t1);
                ..............
                .............
            }
            ......................
            ........................
            threads.ForEach(_ => _.Abort());
     }
     Команда  ----------- threads.ForEach(_ => _.Abort());-------------- ставится перед закрытием блока MAIN  

Чтобы проверить сколько времени берёт выполнение той или иной команды (в нашем случае трэд) можно использовать пространство имён 
    "STOPWATCH":
        Stopwatch sw = new Stopwatch();
        sw.Start();
        Thread t1 = new Thread(foo);
        t1.IsBackground = true;
        t1.Start();
        sw.Stop();
        long ticks = sw.ElapsedMilliseconds;


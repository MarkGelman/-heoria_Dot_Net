
------------------------------------------------------------ PROGRAM.CS ------------------------------------------------------------

Вся программа состоит из процессов(VS,Word,Any Desk...) кот состоят из threads.Процесс заканчивается только когда заканчиваются 
все Threads его.
Foreground - важный трэйд
Daemon - второстепеный трэйдПроцессор может задействовать только один трэйд одновременно.
Библиотека TPN разбивает большой трэйд на несколько трейдов более маленьких. К примеру, Main - это трэйд, кот в свою очередь можно
разбить на несколько небольших трэйдов.

Если в режиме Debug навести курсор на ct то в intellicenc получим следующую инфу:
     IsAlive (true/false) => продолжает работать или закончился;
     IsBackground (true/false) => трэйд главный или второстепеный;
     IsThreadPoolThread (true/false) => это патерн в проге кот позволяет концентрировать много трэйдов в одном месте,
        чтобы их можно было быстро задействовать;
     ManagedThreadId => это трэйд кот привязан к CLR. На курсе мы будем работать толька с такими трэйдами;
     Name => имя не всегда вводят -- эта вещь не обязательна;
     Priority => Степень значимости данного трэйда (HiPriority,Normal,LowPriority). Уже не используют т.к было много проблем
     ThreadState => на каком этапе находится данный трэйд (Running, Start ...)

 int result = Convert.ToInt32(Console.ReadLine()) --> Этот процесс называется "BLOCKING". В это время комп висит и ждёт пока
     пользователь не введёт требуюмую инфу. Чтобы избежать такую потерю времени были придуманы трэйды ("THREAD")
 Трэйды предназначены, для того чтобы в это время комп что-то делал, а не ждал пока дейтсвующий процесс закончится.
Thread t1_ = new Thread(() => { }) --> так создают Thread по имени "t1" с "lambda expression" --> это безымяная фукция где "() =>
     означает что это функция у которой есть тело. Тело функции пишут в "{}"
                
Thread t1 = new Thread(foo) -- создаёт Thread по имени t1 ,кот обращается к функции кот не является безымяной.
     (в даном примере обращении идёт к ф-ции по имени "foo"):

Thread.Sleep(1000) --> он прекращает работу Thread на то к-во времени кот указано в скобках. Выполнил итерацию 
      и "заснул" --> указаное время прошло --> "проснулся" и выполнил следующую итерацию цикла в Main.

После выполнения приведённого ниже -- t1.Start() -- трэд по имени t1 начнёт выполняться. А трэд Main "заснёт". 

Трэд t1 выполнит свои десять итераций в ф-ции "foo" раньше, чем трэд Main проснётся т.к каждая итерация его цикла "засыпает"
на 80 милисекунд, то есть весь цикл выполнится за 80*10=800 милисекунд а "сон" Main длится 1000 милисекунд(Sleep(1000))
800<1000 --> поэтому цикл ф-ции foo выполнится быстрее чем "проснётся" трэд в MAIN.
В том случае, когда трэйд  t1 не успервает полностью выполнить весь цикл до того когда трэд MAIN проснётся (t1.Sleep(200) -->
200*10 = 2000 --> 2000 > 1000), то эти два трэда начинают работать одновремено 

t1.IsBackground = true --> это распоряжение превращает трэд t1 во второстепеный трэд. Все второстепеные трэды заканчиваются вместе с
    основным трэдом (в нашем случае основной трэд это MAIN) и не важно успели они закончится или нет. По умолчанию все трэды являются
    основными ("foreground"), т.е "IsBackground = false". Чтобы "превратить" их во второстепеные используется команда "IsBackground
    = true"

Если нужно сохранить все трэды как основные, но при этом они все должны закончится с завершением работы MAIN, то для этого нужно
использовать команду ABORT. Для этого нужно поместить все трэды кроме MAIN в отдельный LIST:
    
 
Thread.CurrentThread.ManagedThreadId} --> эта команда возвращает порядковый номер трэда (его уникальное имя или номер), кот
    автоматически присваивает ему комп.
    static void Main(string[] args)
    { 
            List<Thread> threads = new List<Thread>();
            for (int i = 3; i >= 0; i--)
            {
                ...............
                ...............
                ...............
                Thread t1 = new Thread(foo);
                threads.Add(t1);
                ..............
                .............
            }
            ......................
            ........................
            threads.ForEach(_ => _.Abort());
     }
     Команда  ----------- threads.ForEach(_ => _.Abort());-------------- ставится перед закрытием блока MAIN  

Чтобы проверить сколько времени берёт выполнение той или иной команды (в нашем случае трэд) можно использовать пространство имён 
    "STOPWATCH":
        Stopwatch sw = new Stopwatch();
        sw.Start();
        Thread t1 = new Thread(foo);
        t1.IsBackground = true;
        t1.Start();
        sw.Stop();
        long ticks = sw.ElapsedMilliseconds;

**************************************************************************************************************************************
*                                            СИСТЕМА РАБОТЫ THREAD-а     31-01-21                                                    *        *
**************************************************************************************************************************************

1. UNSTARTED - тред не подключён к работе
2. Started - находится на старте ожидая выстрела стартового пистолета. Ещё не включён в работу.
3. RUNING - тред начинает выполнять функцию которя в нём хранится. Когда же время отведёное ему процессором заканчивается, но ф-ция в
            треде ещё не закончила работу(процессор переодически прерывает работу треда, чтобы запустить в работу другой тред) --> трэд
            снова возвращается в положение STARTED (положение 2) cнова ожидая выстрела стартового пистолета и так пока функция в треде
            не закончит свою работу!!!        
4.SLEEP(time) - выполняя данный оператор,тред впадает в спячку на время указаное в скобках возвращаясь в положение (2).
5.WAIT() - возвращает тред в положение (2), но в отличие от (4) тред может снова не вернуться в работу до конца выполнения программы.
            если указать в скобках время, то тред подождёт до конца отведённого ему времени и если ни кто его не вызвал, то только 
            тогда возвращается в положение (2).
6.JOIN - тред прекращает свою работу пока другой указаный тред не закончит свою.Используется когда трабуется взаимосвязаная работа
         ф-ций находящихся в разных тредах.
7.Yield - возвращает тред на позицию (2), но на очень короткое время. Используется в основном для задержки выполнения треда
7.SUSPEND - останавливает тред и только после RESUME тред возвращается в положение (2).
8.ABORT - тред прекращает свою работу безотносительно того закончила его ф-ция работу или нет.
9.BLOCK - связан с процессами которые находятся вне системы .NET.

10.ThreadPool - это внутрений класс .NET являющийся "кладовой" для тредов. Он позволяет получить новый тред бед получение объекта класса TREAD.
             Тоесь не нужно получать объект класса через new Tread(). Это экономит очень много времени когда требуется исполнить большое к-ва тредов.
             Чтобы "вытянуть" новый тред из этого класса, нужно вызвать его ф-цию:

                    TreadPool.QueueUserWorkItem(object obj)
            
----------------------------------------------------------- join_treads.cs -----------------------------------------------------------
1. Если после 
                    Thread counterThread = new Thread(() =>
            {
                for (int i = 1; i <= 5; i++)
                {
                    Console.WriteLine(i);
                    Thread.Sleep(1 * 1000);
                }
            });

   1) если после выше приведёный строк написать сразу же оператор counterThread.Start() - то функция не закончится пока тред не перестанет
        работать так как данный тред является важным.
   2) если после закрытия лямбда-выражения написать :

                                            counterThread.IsBackground = true;
                                            counterThread.Start();

      то тогда ф-ция прекратит свою работу да окончания работы counterThread, так как указали что этот тред не является важным.
   3) если после закрытия лямбда-выражения написать :

                                            counterThread.IsBackground = true;
                                            counterThread.Start();
                                            
      то тогда ф-ция будет ждать окончания треда, так как указан оператор counterThread.Join() и тогда не важно counterThread
      является важным или второстепеным тредом.
      
----------------------------------------------------------- WorkerQueue.cs -----------------------------------------------------------
1. Lock (key) - это блок в котором помещенно такое д-вие, которое не могут делать два треда одновременно. Когда в блок заходит один 
                тред, то блок автоматически закрывается. В такой блок не может зайти одновременно больше чем один тред. Когда тред
                внутри блока закончит свою работу --> ключ от блока(key) передаётся следующему треду, который "ждёт" на входе в блок

    Lock (key)
   {
        Удаление члена из массива (!!!если два или больше тредов будут пытаться удалить один и тот же член -- это приведёт к ошибке!!!)
   }

   Пример из нашего класса:
   Action work_func = null;
   lock (key)
            {
                while (m_queue.Count == 0)
                {
                    Thread.Yield();
                }
                work_func = m_queue[m_queue.Count - 1]; // 1
                m_queue.RemoveAt(m_queue.Count - 1); // 1
            }

            work_func.invoke():

 Cуществует ещё одна проблема. Возможно, что когда тред зайдёт в блок в нём ещё не будет всей инфы требуемой для работы треда
 (В нашем случае ф-ция Produce не успеют "зарядить" работу в тред из листа m_queue). Поэтому в треде выше поставлена задержка
  ввиде WHILE-блока на тот случай,если тред зашёл,а лист m_queue всё ещё пуст.
  

  !!!                                                                                                                !!!
        Важно, что запуск треда (в нашем случае work_func.invoke()) должен быть сделан не в LOCK-блоке,а после него.
        Так как в ином случае тред не выйдет из блока пока не закончит свою работу --> другой тред не сможет зайти
        --> не нужная потеря времени!
  !!!                                                                                                                !!!
  
  ----------------------------------------------------------- SolutionTargil.cs -----------------------------------------------------------

